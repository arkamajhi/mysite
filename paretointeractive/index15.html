<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Pareto Frontier Explorer</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<script src="https://d3js.org/d3.v7.min.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
<style>
/* CSS Reset and Global Styles */
body {
    font-family: 'Roboto', sans-serif;
    margin: 0;
    padding: 0;
    background: #f5f5f5;
    color: #333;
    height: 100vh;
    overflow: hidden;
    box-sizing: border-box;

    /* Grid layout for Desktop: Fixed 250px for controls, rest for chart */
    display: grid;
    grid-template-columns: 250px 1fr;
    grid-template-rows: 100vh;
}
h2 {
    font-weight: 700;
    text-align: center;
    margin-bottom: 10px;
    font-size: 1.1em;
}

/* LEFT PANEL (Controls) üì¶ */
.controls-panel {
    grid-column: 1 / 2;
    background: #e0e0e0;
    padding: 10px;
    overflow-y: auto;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    gap: 10px;
}
.controls-panel h2 {
    margin-top: 5px;
    margin-bottom: 8px;
    font-size: 1em;
}

/* RIGHT PANEL (Chart) üìä */
.chart-panel {
    grid-column: 2 / 3;
    background: #f5f5f5;
    padding: 15px;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
}

/* Card Styling (Panel) */
.panel {
    background: white;
    border-radius: 8px;
    padding: 8px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
}

/* GLOBAL: Center Panel Headers */
.panel h3 {
    margin: 0;
    font-weight: 700;
    font-size: 0.9em;
    text-align: center;
}

/* Collapsible Header Styling */
.panel-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    cursor: pointer;
    margin-bottom: 0;
    padding-bottom: 5px;
    border-bottom: 1px solid transparent;
}
.panel-header h3 {
    text-align: left;
}
.panel-header:hover {
    color: #2196F3;
}
.toggle-icon {
    font-size: 0.8em;
    transition: transform 0.2s;
}
/* Rotate icon when content is shown */
.panel:not(.collapsed) .toggle-icon {
    transform: rotate(180deg);
}

/* Content Area for Collapsible Cards */
.panel-content {
    overflow: hidden;
    max-height: 500px;
    transition: max-height 0.3s ease-in-out;
}
/* Collapse state */
.panel.collapsed .panel-content {
    max-height: 0;
    padding-top: 0;
}
/* Separator for better collapsed look */
.panel:not(.collapsed) .panel-content {
    padding-top: 8px;
    border-top: 1px solid #eee;
}

/* Form Elements Styling (Base for select and file input) */
select, input[type="file"] {
    padding: 4px 6px;
    font-size: 11px;
    border-radius: 4px;
    border: 1px solid #ccc;
    box-sizing: border-box;
    appearance: none;
    -webkit-appearance: none;
}

/* Centering the File Input Element */
#fileInput {
    padding: 5px;
    background-color: #f9f9f9;
    cursor: pointer;
    border: 1px dashed #aaa;
    margin: 5px auto;
    display: block;
    width: 95%;
    max-width: 100%;
}

/* --- X/Y VARIABLE SELECTION ALIGNMENT FIX --- */
#varsPanel .form-row {
    flex-direction: column;
    align-items: flex-start;
    margin-top: 5px;
    padding: 0 5px;
}

/* --- DYNAMIC VARIABLE SELECT STYLES (TRUNCATION FIX HERE) --- */
.var-select-row {
    margin-bottom: 10px;
    width: 100%;
}
.var-select-row label {
    font-size: 0.9em;
    font-weight: bold;
    display: block;
    margin-bottom: 3px;
    width: 100%;
    margin: 0;
    text-align: left;
}
.input-group {
    display: flex;
    gap: 5px;
    align-items: center;
    width: 100%;
    margin: 0;
}

/* CRITICAL FIX FOR TRUNCATION IN FLEXBOX */
.var-dropdown {
    flex-grow: 1;
    min-width: 0; /* Forces the flex item to shrink and respect container limits */

    /* Required for text-overflow: ellipsis */
    overflow: hidden;
    white-space: nowrap;
    text-overflow: ellipsis;
}
/* END CRITICAL FIX */

.add-var-btn {
    padding: 2px 8px;
    border: 1px solid #2196F3;
    background-color: #2196F3;
    color: white;
    font-size: 14px;
    line-height: 1;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.2s;
    flex-shrink: 0;
}
.add-var-btn:hover {
    background-color: #0b7dda;
}
/* --- END DYNAMIC VARIABLE SELECT STYLES --- */


/* --- CUSTOM DRAGGABLE SLIDER STYLES --- */

/* Wrapper for the track and handle */
.weight-control-wrapper {
    position: relative;
    height: 32px;
    margin-top: 5px;
    width: 90%;
    margin-left: auto;
    margin-right: auto;
}

/* The visual track line */
.slider-track {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    width: 100%;
    height: 4px;
    background-color: #aaa;
    border-radius: 2px;
}

/* The Draggable Number Box / Handle */
.weight-draggable-handle {
    position: absolute;
    top: 50%;
    transform: translate(-50%, -50%);

    width: 38px;
    height: 24px;
    padding: 0;
    text-align: center;
    font-weight: bold;
    font-size: 11px;

    border-radius: 4px;
    border: 1px solid #333;
    box-sizing: border-box;

    cursor: grab;
    z-index: 10;

    -moz-appearance: textfield;
    transition: box-shadow 0.1s;
}
.weight-draggable-handle::-webkit-outer-spin-button,
.weight-draggable-handle::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
}
.weight-draggable-handle:focus {
    outline: none;
    box-shadow: 0 0 0 2px rgba(33, 150, 243, 0.5);
}
.dragging {
    cursor: grabbing !important;
    box-shadow: 0 0 5px rgba(33, 150, 243, 0.7);
    background-color: #e3f2fd;
}

/* --- END CUSTOM DRAGGABLE SLIDER STYLES --- */

/* Switch */
.switch { position: relative; display: inline-block; width: 30px; height: 16px; }
.switch input { display: none; }
.slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: 0.3s; border-radius: 34px; }
.slider:before { position: absolute; content: ""; height: 12px; width: 12px; left: 2px; bottom: 2px; background-color: white; transition: 0.3s; border-radius: 50%; }
input:checked + .slider:before { transform: translateX(14px); }

/* Custom Switch Colors */
.switch input.red-switch:checked + .slider { background-color: #F44336; }
.switch input.green-switch:checked + .slider { background-color: #4CAF50; }
.switch input.blue-switch:checked + .slider { background-color: #2196F3; }
.switch input.black-switch:checked + .slider { background-color: #333; }

/* SVG Chart: Maximized to fill the entire right panel */
#chart {
    width: 100%;
    height: 100%;
    border-radius: 8px;
    background: white;
    box-shadow: 0 4px 10px rgba(0,0,0,0.1);
}

/* Toggles and Weight Grid */
.toggles {
    display: flex;
    flex-direction: column;
    gap: 8px;
}
.toggle-group {
    display: flex;
    flex-direction: column;
    gap: 3px;
    margin-bottom: 5px;
}
.toggle-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
    font-size: 0.9em;
    font-weight: bold;
    transition: color 0.3s;
    cursor: pointer;
}
.form-row label {
    display: flex;
    flex-direction: column;
    gap: 3px;
    width: 100%;
}
.weight-grid {
    display: flex !important;
    flex-direction: column;
    gap: 8px;
}

.info-panel { margin-top: 10px; font-weight: 700; font-size: 0.9em; }
.tooltip { position: absolute; padding: 6px 10px; background: rgba(0,0,0,0.7); color: white; border-radius: 4px; font-size: 12px; pointer-events: none; }

.pulse { fill: orange; animation: pulse 1.2s infinite; }
@keyframes pulse {
    0% { r: 6; opacity: 0.5; }
    50% { r: 12; opacity: 0.2; }
    100% { r: 6; opacity: 0.5; }
}


/* Mobile/Small Screen Fallback: Stack vertically */
@media (max-width: 768px) {
    body {
        grid-template-columns: 1fr;
        grid-template-rows: auto 1fr;
        height: auto;
        overflow-y: auto;
    }
    .controls-panel {
        grid-column: 1 / 2;
        grid-row: 1 / 2;
        width: 100%;
        height: auto;
        max-height: 90vh;
        padding: 10px;
        gap: 10px;
    }
    .chart-panel {
        grid-column: 1 / 2;
        grid-row: 2 / 3;
        padding: 10px;
        min-height: 60vh;
    }
    #chart {
        height: 60vh;
    }
    h2 { font-size: 1.5em; }
}
</style>
</head>
<body>

<!-- LEFT CONTROL PANEL (250px on desktop) -->
<div class="controls-panel">
    <h2 id="page-header">Pareto Explorer</h2>

    <!-- 1. File Upload -->
    <div class="panel">
        <h3>Upload Data üìÅ</h3>
        <input type="file" id="fileInput" accept=".csv" title="Browse for a CSV file">
    </div>

    <!-- 2. X/Y Selection (Panel 2) -->
    <div class="panel" id="varsPanel">
        <h3>Choose Variables</h3>
        <div class="form-row" style="flex-direction: column; margin-top: 5px;">
            <div id="xVarContainer">
                <!-- X variable dropdowns will be dynamically inserted here -->
            </div>
            <div id="yVarContainer">
                <!-- Y variable dropdowns will be dynamically inserted here -->
            </div>
        </div>
    </div>

    <!-- 3. Weighted Management (Panel 3) -->
    <div class="panel collapsed" id="weightedPanel">
        <div class="panel-header">
            <h3>Weighted Management</h3>
            <span class="toggle-icon">‚ñº</span>
        </div>
        <div class="panel-content">
            <div id="weightInputs" class="weight-grid">

                <!-- Management 1 Weight UI -->
                <div class="form-row" style="flex-direction: column; align-items: center;">
                    <label>Management 1: <select id="mgmt1"></select></label>
                    <!-- Custom Draggable Slider Wrapper -->
                    <div class="weight-control-wrapper" data-id="1">
                        <div class="slider-track"></div>
                        <input type="number" class="weight-draggable-handle" id="weightVal1" min="0" max="100" value="50" readonly>
                    </div>
                </div>

                <!-- Management 2 Weight UI -->
                <div class="form-row" style="flex-direction: column; align-items: center;">
                    <label>Management 2: <select id="mgmt2"></select></label>
                    <!-- Custom Draggable Slider Wrapper -->
                    <div class="weight-control-wrapper" data-id="2">
                        <div class="slider-track"></div>
                        <input type="number" class="weight-draggable-handle" id="weightVal2" min="0" max="100" value="50" readonly>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 4. Toggles (Panel 4) -->
    <div class="panel collapsed" id="togglesPanel">
        <div class="panel-header">
            <h3>Toggle Pareto Fronts</h3>
            <span class="toggle-icon">‚ñº</span>
        </div>
        <div class="panel-content">
            <div class="toggles">

                <!-- R55 Toggle Group -->
                <div class="toggle-group" id="groupR55">
                    <label class="toggle-row" data-color="#F44336" data-id="R55">
                        <span>55 years</span>
                        <label class="switch">
                            <input type="checkbox" id="toggleR55" class="red-switch" checked>
                            <span class="slider"></span>
                        </label>
                    </label>
                </div>

                <!-- R65 Toggle Group -->
                <div class="toggle-group" id="groupR65">
                    <label class="toggle-row" data-color="#4CAF50" data-id="R65">
                        <span>65 years</span>
                        <label class="switch">
                            <input type="checkbox" id="toggleR65" class="green-switch" checked>
                            <span class="slider"></span>
                            </label>
                    </label>
                </div>

                <!-- R75 Toggle Group -->
                <div class="toggle-group" id="groupR75">
                    <label class="toggle-row" data-color="#2196F3" data-id="R75">
                        <span>75 years</span>
                        <label class="switch">
                            <input type="checkbox" id="toggleR75" class="blue-switch" checked>
                            <span class="slider"></span>
                        </label>
                    </label>
                </div>

                <!-- Overall Toggle Group -->
                <div class="toggle-group" id="groupLineOverall">
                    <label class="toggle-row" data-color="black" data-id="LineOverall">
                        <span>Pareto Optimal</span>
                        <label class="switch">
                            <input type="checkbox" id="toggleLineOverall" class="black-switch" checked>
                            <span class="slider"></span>
                        </label>
                    </label>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- RIGHT CHART PANEL (90vw / 1fr) -->
<div class="chart-panel">
    <div class="panel" style="flex: 1; min-height: 0;">
        <svg id="chart"></svg>
        <div class="info-panel" id="crossInfo">Weighted Cross: X=0, Y=0</div>
    </div>
</div>

<div class="tooltip" id="tooltip" style="opacity:0;"></div>

<script>
const svg = d3.select("#chart");
const tooltip = d3.select("#tooltip");
const crossInfo = d3.select("#crossInfo");
const TOGGLE_IDS = ["R55", "R65", "R75", "LineOverall"];
const INACTIVE_COLOR = '#999';

let data=[], xVar="", yVar="", cross, xScale, yScale;
let xCount = 0; // Tracks number of X dimension dropdowns
let yCount = 0; // Tracks number of Y dimension dropdowns

// --- Custom Draggable Handle Logic (Slider Implementation) ---
let isDragging = false;
let currentInput = null;
let containerRect = null;

/**
 * Updates the CSS left property of the handle based on its current value.
 */
function updateHandlePosition(inputEl) {
    if (!inputEl) return;
    const value = +inputEl.value;
    const min = +inputEl.min;
    const max = +inputEl.max;
    const wrapper = inputEl.closest('.weight-control-wrapper');
    if (!wrapper) return;

    const wrapperWidth = wrapper.clientWidth;

    // Calculate position as a percentage of the track width
    const normalizedValue = (value - min) / (max - min);

    // Calculate pixel position. This positions the center of the handle.
    const pixelPosition = normalizedValue * wrapperWidth;

    // Apply position, and the CSS transform(-50%, -50%) centers the handle
    inputEl.style.left = `${pixelPosition}px`;
}

/**
 * Starts the drag operation on mousedown or touchstart.
 */
function startDrag(event) {
    const target = event.target;
    if (target.classList.contains('weight-draggable-handle')) {
        event.preventDefault();

        isDragging = true;
        currentInput = target;
        currentInput.classList.add('dragging');

        const wrapper = currentInput.closest('.weight-control-wrapper');
        containerRect = wrapper.getBoundingClientRect();

        document.addEventListener('mousemove', onDrag);
        document.addEventListener('mouseup', endDrag);
        document.addEventListener('touchmove', onDrag, { passive: false });
        document.addEventListener('touchend', endDrag);
    }
}

/**
 * Handles the drag movement.
 */
function onDrag(event) {
    if (!isDragging || !currentInput) return;

    event.preventDefault();
    const clientX = event.touches ? event.touches[0].clientX : event.clientX;

    let relativeX = clientX - containerRect.left;

    // Constrain relativeX to the bounds of the wrapper (0 to wrapper width)
    relativeX = Math.max(0, Math.min(containerRect.width, relativeX));

    const min = +currentInput.min;
    const max = +currentInput.max;

    // Calculate the new value based on the relative position
    const normalizedValue = relativeX / containerRect.width;
    let newValue = Math.round(normalizedValue * (max - min));

    newValue = Math.max(min, Math.min(max, newValue));

    // Update the input field value and CSS position
    currentInput.value = newValue;
    updateHandlePosition(currentInput);

    // Update the chart visualization
    updateWeightedCross();
}

/**
 * Ends the drag operation.
 */
function endDrag() {
    if (!isDragging) return;

    isDragging = false;
    if (currentInput) {
        currentInput.classList.remove('dragging');
    }
    currentInput = null;

    document.removeEventListener('mousemove', onDrag);
    document.removeEventListener('mouseup', endDrag);
    document.removeEventListener('touchmove', onDrag, { passive: false });
    document.removeEventListener('touchend', endDrag);
}

// Attach mousedown and touchstart listeners to the document
document.addEventListener('mousedown', startDrag);
document.addEventListener('touchstart', startDrag, { passive: false });
// --- End Custom Draggable Handle Logic ---


function updateToggleStyle(id, checked) {
    const row = document.querySelector(`#group${id} .toggle-row`);
    const color = row.getAttribute('data-color');
    if (row) row.style.color = checked ? color : INACTIVE_COLOR;
}

function handleResize() {
    window.requestAnimationFrame(() => {
        // The xVar/yVar in this scope are stale. We need to check if we can plot based on data presence.
        if (data.length > 0) {
            plotData();
        }
        // Reposition handles on resize
        document.querySelectorAll('.weight-draggable-handle').forEach(updateHandlePosition);
    });
}
window.addEventListener('resize', handleResize);

// Collapsible Panel Logic
document.querySelectorAll('.panel-header').forEach(header => {
    header.addEventListener('click', function() {
        const panel = this.closest('.panel');
        panel.classList.toggle('collapsed');

        const isEnabled = !panel.classList.contains('collapsed');
        if (panel.id === 'weightedPanel' && isEnabled) {
            // Set initial positions when opening
            document.querySelectorAll('.weight-draggable-handle').forEach(updateHandlePosition);
        }
        updateWeightedCross(isEnabled);
    });
});


/**
 * Populates a given select element with variable names.
 * @param {HTMLElement} dropdownElement - The <select> element to populate.
 * @param {string[]} data - Array of column/variable names.
 */
function populateDropdown(dropdownElement, data) {
    d3.select(dropdownElement).selectAll("option").data(data).join("option").text(d => d).attr("value", d => d);
}

/**
 * Creates the HTML structure for a new variable selection dropdown (including the button).
 * @param {string} axis - 'x' or 'y'.
 * @param {number} index - The dimension index (1 for primary, 2, 3, etc.).
 * @param {string} label - The text label for the dropdown.
 * @returns {HTMLElement} The newly created <select> element.
 */
function createDropdownHTML(axis, index, label) {
    const containerId = axis === 'x' ? 'xVarContainer' : 'yVarContainer';
    const container = document.getElementById(containerId);

    // Remove the previous '+' button before appending the new row
    container.querySelectorAll('.add-var-btn').forEach(btn => btn.remove());

    const newRow = document.createElement('div');
    newRow.classList.add('var-select-row');
    newRow.innerHTML = `
        <label>${label}:</label>
        <div class="input-group">
            <select class="var-dropdown" id="${axis}Var${index}" data-axis="${axis}" data-index="${index}"></select>
            <button class="add-var-btn" data-axis="${axis}">+</button>
        </div>
    `;
    container.appendChild(newRow);

    const addButton = newRow.querySelector('.add-var-btn');
    const selectElement = newRow.querySelector('.var-dropdown');

    // Attach new event listener to the dynamically created '+' button
    addButton.addEventListener('click', () => {
        addVariableDropdown(axis);
    });

    // Attach change listener to the new select element (only primary dimension triggers plot)
    selectElement.addEventListener('change', function() {
        if(this.dataset.index === '1') {
            plotData();
        }
    });

    return selectElement;
}

/**
 * Adds a new variable selection dropdown for the given axis.
 * @param {string} axis - 'x' or 'y'.
 */
function addVariableDropdown(axis) {
    // Get variables only if data is present
    const vars = data.length > 0 ? Object.keys(data[0]) : [];

    let index;
    if (axis === 'x') {
        xCount++;
        index = xCount;
    } else if (axis === 'y') {
        yCount++;
        index = yCount;
    } else {
        return;
    }

    // UPDATED LOGIC: Removed "Dim" from the label for index > 1
    let labelText;
    if (index === 1) {
        labelText = `${axis.toUpperCase()} Variable`;
    } else {
        labelText = `${axis.toUpperCase()} Variable (${index})`;
    }


    const dropdown = createDropdownHTML(axis, index, labelText);

    // Populate dropdown with actual vars if available, otherwise it remains empty
    populateDropdown(dropdown, vars);

    // FIX: If no data is loaded, disable the dropdown and the add button.
    const hasData = data.length > 0;
    dropdown.disabled = !hasData;

    // The button is the sibling of the select element's parent container
    const addButton = dropdown.parentElement.querySelector('.add-var-btn');
    if (addButton) {
        addButton.disabled = !hasData;
    }
}


// CSV upload
d3.select("#fileInput").on("change", function() {
  const file = this.files[0];
  if(!file) return;
  d3.csv(URL.createObjectURL(file)).then(csv => {
    data = csv;
    const vars = Object.keys(data[0]);

    // Reset variable counters and containers
    xCount = 0; // Will be incremented to 1 in the function call
    yCount = 0; // Will be incremented to 1 in the function call
    document.getElementById('xVarContainer').innerHTML = '';
    document.getElementById('yVarContainer').innerHTML = '';

    // Initialize primary X variable dropdown (Dim 1) - addVariableDropdown now handles population and enabling
    addVariableDropdown('x');

    // Initialize primary Y variable dropdown (Dim 1) - addVariableDropdown now handles population and enabling
    addVariableDropdown('y');

    // Populate Management regime dropdowns
    const mgmtCodes = Array.from(new Set(data.map(d=>d["Management regime"])));
    populateDropdown(d3.select("#mgmt1").node(), mgmtCodes);
    populateDropdown(d3.select("#mgmt2").node(), mgmtCodes);

    // Plot data if primary variables have been set (which they should be now)
    const xDropdown1 = document.getElementById('xVar1');
    const yDropdown1 = document.getElementById('yVar1');

    if (xDropdown1 && xDropdown1.value && yDropdown1 && yDropdown1.value) {
        plotData();
    }
  }).catch(error => {
    console.error("Error loading file: ", error.message);
  });
});


d3.select("#mgmt1").on("change", () => updateWeightedCross());
d3.select("#mgmt2").on("change", () => updateWeightedCross());


// Manually typing in the number box (for fine tuning)
document.querySelectorAll('.weight-draggable-handle').forEach(inputEl => {
  inputEl.addEventListener("change", function(){
    let val = +this.value;
    if (val < 0) val = 0;
    if (val > 100) val = 100;
    this.value = val; // Force value back into bounds
    updateHandlePosition(this); // Reposition the handle based on the manually typed value
    updateWeightedCross();
  });
});


// Weighted point calculation
function getWeightedPoint(m1,m2,w1,w2){
  const filtered = data.filter(d=>+d["Climate code"]===1);
  const d1 = filtered.find(d=>d["Management regime"]===m1);
  const d2 = filtered.find(d=>d["Management regime"]===m2);
  if(!d1 || !d2) return null;

  const x1 = parseFloat(d1[xVar]);
  const y1 = parseFloat(d1[yVar]);
  const x2 = parseFloat(d2[xVar]);
  const y2 = parseFloat(d2[yVar]);

  if(isNaN(x1) || isNaN(y1) || isNaN(x2) || isNaN(y2) || (w1+w2)===0) return null;

  const x = (w1*x1 + w2*x2)/(w1+w2);
  const y = (w1*y1 + w2*y2)/(w1+w2);

  return {x,y};
}

// PPF/Pareto frontier (Upper-Right Maximization)
function computePPF(points){
  if(points.length===0) return [];

  const sorted = points.sort((a,b)=>{
    if(b.x !== a.x) return b.x - a.x;
    return b.y - a.y;
  });

  const pareto = [];
  let maxY = -Infinity;

  for(const p of sorted){
    if(p.y >= maxY){
      pareto.push(p);
      maxY = p.y;
    }
  }

  const maxYY = d3.max(points, d => d.y);
  const maxPointY = points.find(d => d.y === maxYY);

  if (maxPointY && (pareto.length === 0 || pareto[pareto.length - 1].y < maxYY)) {
    if (!pareto.some(p => p.x === maxPointY.x && p.y === maxPointY.y)) {
        pareto.push(maxPointY);
    }
  }

  return pareto;
}

// Core Plotting Function
function plotData(){
    // Find the primary X and Y variables from the first dropdowns
    const primaryXDropdown = document.querySelector('#xVarContainer select[data-index="1"]');
    const primaryYDropdown = document.querySelector('#yVarContainer select[data-index="1"]');

    // Set the global variables to the primary selection for 2D plotting
    xVar = primaryXDropdown ? primaryXDropdown.value : "";
    yVar = primaryYDropdown ? primaryYDropdown.value : "";

    if(!xVar || !yVar || data.length === 0) return;

    // Data processing and filtering
    const filtered = data.filter(d=>+d["Climate code"]===1);
    const points = filtered.map(d=>{
      const rotationMatch = d["Management regime"].match(/R(\d+)/);
      const rot = rotationMatch ? +rotationMatch[1] : 0;
      let color = rot===55?"red":rot===65?"green":rot===75?"blue":"gray";
      const xVal = parseFloat(d[xVar]);
      const yVal = parseFloat(d[yVar]);
      if(isNaN(xVal) || isNaN(yVal)) return null;
      return {x:xVal, y:yVal, color, rotation:rot, raw:d};
    }).filter(d=>d!==null);

    if(points.length===0) return;

    const frontiers = [55,65,75].map(rot=>{
      const pts = points.filter(p=>p.rotation===rot).map(p=>({x:p.x,y:p.y}));
      return {rotation:rot, frontier:computePPF(pts)};
    });
    const overallFrontier = computePPF(points.map(p=>({x:p.x,y:p.y})));

    // D3 setup and plotting
    svg.selectAll("*").remove();
    const width = parseInt(svg.style("width")), height = parseInt(svg.style("height"));
    const margin = {top:30,right:30,bottom:50,left:70};
    const innerWidth = width-margin.left-margin.right;
    const innerHeight = height-margin.top-margin.bottom;
    const g = svg.append("g").attr("transform",`translate(${margin.left},${margin.top})`);

    xScale = d3.scaleLinear().domain([0,d3.max(points,d=>d.x)]).range([0,innerWidth]).nice();
    yScale = d3.scaleLinear().domain(d3.extent(points,d=>d.y)).nice().range([innerHeight,0]);

    // Axes
    g.append("g").attr("transform",`translate(0,${innerHeight})`).call(d3.axisBottom(xScale));
    g.append("text").attr("x",innerWidth/2).attr("y",innerHeight+40).text(xVar).style("font-weight","bold").style("text-anchor","middle");
    g.append("g").call(d3.axisLeft(yScale));
    g.append("text").attr("transform","rotate(-90)").attr("x",-innerHeight/2).attr("y",-50).text(yVar).style("font-weight","bold").style("text-anchor","middle");

    // Dots and rotation lines combined
    frontiers.forEach(f=>{
      points.filter(p=>p.rotation===f.rotation).forEach(p=>{
        g.append("circle")
          .attr("cx",xScale(p.x)).attr("cy",yScale(p.y))
          .attr("r",4).attr("fill",p.color)
          .attr("class","dotR"+p.rotation)
          .on("mouseover",(event,d)=>{ tooltip.transition().duration(200).style("opacity",1);
            tooltip.html(`${xVar}: ${p.x.toFixed(2)}<br>${yVar}: ${p.y.toFixed(2)}`)
              .style("left",(event.pageX+10)+"px").style("top",(event.pageY-28)+"px");})
          .on("mouseout",()=>tooltip.transition().duration(200).style("opacity",0));
      });
      g.append("path").datum(f.frontier)
        .attr("fill","none")
        .attr("stroke",f.rotation===55?"#F44336":f.rotation===65?"#4CAF50":"#2196F3")
        .attr("stroke-width",2)
        .attr("stroke-dasharray","5,5")
        .attr("class","paretoR"+f.rotation)
        .attr("d",d3.line().x(d=>xScale(d.x)).y(d=>yScale(d.y)).curve(d3.curveLinear));
    });

    // Overall line
    g.append("path").datum(overallFrontier)
      .attr("fill","none").attr("stroke","black")
      .attr("stroke-width",2).attr("class","paretoLineOverall")
      .attr("d",d3.line().x(d=>xScale(d.x)).y(d=>yScale(d.y)).curve(d3.curveLinear));

    // Weighted pulsating point initialization/update
    const m1Init=d3.select("#mgmt1").property("value");
    const m2Init=d3.select("#mgmt2").property("value");
    const w1Init=+d3.select("#weightVal1").property("value");
    const w2Init=+d3.select("#weightVal2").property("value");
    const weightedInit = getWeightedPoint(m1Init,m2Init,w1Init,w2Init);

    cross = svg.select(".weighted-cross-group");
    if (cross.empty()) {
        cross = g.append("g").attr("class", "weighted-cross-group");
        cross.append("circle").attr("class","pulse");
        cross.append("circle").attr("r",3).attr("fill","black");
    }

    // Check panel state for initial visibility
    const isWeightedPanelOpen = !d3.select("#weightedPanel").classed('collapsed');

    if(weightedInit){
        cross.style("display", isWeightedPanelOpen ? null:"none");
        cross.select(".pulse")
            .attr("cx",xScale(weightedInit.x)).attr("cy",yScale(weightedInit.y)).attr("r",6)
            .on("mouseover",(event,d)=>{ tooltip.transition().duration(200).style("opacity",1);
                tooltip.html(`**Weighted Point**<br>${xVar}: ${weightedInit.x.toFixed(2)}<br>${yVar}: ${weightedInit.y.toFixed(2)}`)
                .style("left",(event.pageX+10)+"px").style("top",(event.pageY-28)+"px");})
            .on("mouseout",()=>tooltip.transition().duration(200).style("opacity",0));
        cross.select("circle:not(.pulse)")
            .attr("cx",xScale(weightedInit.x)).attr("cy",yScale(weightedInit.y));
        crossInfo.text(`Weighted Cross: X=${weightedInit.x.toFixed(2)}, Y=${weightedInit.y.toFixed(2)}`);
    } else {
        cross.style("display", "none");
        crossInfo.text(`Weighted Cross: X=N/A, Y=N/A (Check management regimes and data)`);
    }

    // Toggle state setup and event listeners
    TOGGLE_IDS.forEach(id=>{
      const toggleElement = d3.select(`#toggle${id}`);
      const isChecked = toggleElement.property("checked");

      updateToggleStyle(id, isChecked);

      toggleElement.on("change", function(){
        const newChecked = this.checked;
        const newDisplay = newChecked?null:"none";

        if (id.startsWith('R')) {
            svg.selectAll(`.dot${id}`).attr("display",newDisplay);
            svg.selectAll(`.pareto${id}`).attr("display",newDisplay);
        } else if (id === 'LineOverall') {
            svg.selectAll(".paretoLineOverall").attr("display",newDisplay);
        }

        updateToggleStyle(id, newChecked);
      });
    });

    // Initial position setup for handles
    if (isWeightedPanelOpen) {
        document.querySelectorAll('.weight-draggable-handle').forEach(updateHandlePosition);
    }
}

// Update weighted point dynamically (used for number input changes/drag)
function updateWeightedCross(forceDisplay = null){
    // Check primary variables again as they are used in getWeightedPoint
    const primaryXDropdown = document.querySelector('#xVarContainer select[data-index="1"]');
    const primaryYDropdown = document.querySelector('#yVarContainer select[data-index="1"]');
    xVar = primaryXDropdown ? primaryXDropdown.value : "";
    yVar = primaryYDropdown ? primaryYDropdown.value : "";

    if(!xScale || !yScale || !xVar || !yVar) return;

    const m1=d3.select("#mgmt1").property("value");
    const m2=d3.select("#mgmt2").property("value");
    const w1=+d3.select("#weightVal1").property("value");
    const w2=+d3.select("#weightVal2").property("value");

    const weightedPoint = getWeightedPoint(m1,m2,w1,w2);
    const isWeightedPanelOpen = !d3.select("#weightedPanel").classed('collapsed');

    // Determine display state
    let displayStyle;
    if (forceDisplay !== null) {
        displayStyle = forceDisplay ? null : "none";
    } else {
        displayStyle = isWeightedPanelOpen && weightedPoint ? null : "none";
    }

    cross = svg.select(".weighted-cross-group");
    if (cross.empty()) {
        // If the chart hasn't been plotted yet, we can't update.
        crossInfo.text(`Weighted Cross: X=N/A, Y=N/A (Plot data first)`);
        return;
    }

    if (weightedPoint) {
        // Update position
        cross.select(".pulse")
            .attr("cx",xScale(weightedPoint.x)).attr("cy",yScale(weightedPoint.y));
        cross.select("circle:not(.pulse)")
            .attr("cx",xScale(weightedPoint.x)).attr("cy",yScale(weightedPoint.y));

        // Update info text
        crossInfo.text(`Weighted Cross: X=${weightedPoint.x.toFixed(2)}, Y=${weightedPoint.y.toFixed(2)}`);

        // Re-attach tooltip logic to the new point position
        cross.selectAll("circle")
            .on("mouseover",(event)=>{ tooltip.transition().duration(200).style("opacity",1);
                tooltip.html(`**Weighted Point**<br>${xVar}: ${weightedPoint.x.toFixed(2)}<br>${yVar}: ${weightedPoint.y.toFixed(2)}`)
                .style("left",(event.pageX+10)+"px").style("top",(event.pageY-28)+"px");})
            .on("mouseout",()=>tooltip.transition().duration(200).style("opacity",0));

        // Set display style
        cross.style("display", displayStyle);

    } else {
        // Hide if weighted point cannot be calculated
        cross.style("display", "none");
        crossInfo.text(`Weighted Cross: X=N/A, Y=N/A (Check management regimes and data)`);
    }
}
// Initial setup: Add default X and Y dimension dropdowns if not yet added
if (document.getElementById('xVar1') === null) {
    addVariableDropdown('x');
}
if (document.getElementById('yVar1') === null) {
    addVariableDropdown('y');
}
</script>
</body>
</html>
